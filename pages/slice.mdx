在 `Go` 语言中，相比于数组，其实 `slice` 使用更为频繁。不过在使用 `slice` 时我们需要谨慎，注意避坑。

### 切割 slice

在实际编程中，我们经常基于现有的 `slice` 切割一个新的 `slice`，类似其他语言数组提供的 `substring()` 方法类似：

```go
sl := []int{1, 8, 7, 4, 4, 5, 2, 4, 10, 0}
s1 := sl[1:5]

fmt.Printf("sl: %v \n", sl)
fmt.Printf("s1: %v \n", s1)
```

上面的代码很简单，我们基于 `sl` 这个原始数组希望切割其中一部分作为新的 `slice`，这个过程其实没问题。新的 `s1` 数组会输出：

```
sl: [1 8 7 4 4 5 2 4 10 0]
s1: [8 7 4 4]
```

但如果接下来我们尝试对现有的切片不管是 `sl` 还是 `s1` 对之前在切割时这部分公共数据元素进行更新值操作时，你会发觉奇怪的问题：

```go
sl := []int{1, 8, 7, 4, 4, 5, 2, 4, 10, 0}
s1 := sl[1:5]
s1[0] = 100

fmt.Printf("sl: %v \n", sl)
fmt.Printf("s1: %v \n", s1)

```

输出结果为：

```
sl: [1 100 7 4 4 5 2 4 10 0]
s1: [100 7 4 4]
```

你会惊奇的发现，**本来只是想对 `s1` 的元素进行更新操作时，竟然原先的老切片也跟着受到了影响。** 之所以会这样，这跟 `Go` 语言里 `slice` 实现有关系，网上关于 `slice` 原理剖析的文章很多，这里不在赘述；**主要是因为 `sl` 和 `s1` 在内部存储的空间上是共享存储区域的，即 `s1` 存储空间是 `sl` 的子集。**，对 `sl` 使用 `[]` 切割新`slice`并不会生成一个新的存储空间切片，至少目前还不会。

那么有什么方式可以避免上述的问题呢？如果你希望新的切片完全和旧的是两个独立的存储空间，那么请使用 `copy()` 函数进行拷贝：

```go
sl := []int{1, 8, 7, 4, 4, 5, 2, 4, 10, 0}
tmp := sl[1:5]

var s1 = make([]int, 4)
copy(s1, tmp)
s1[0] = 100
```

上面直接创建一个新的`slice` 再把切割的子数组所有元素拷贝过去。这样就会得到两个不相干的 `slice`:

```
sl: [1 8 7 4 4 5 2 4 10 0]
s1: [100 7 4 4]
```

在开发中一定要引起注意！不过除了上面的 `copy` 其实还有另一个变通方法，刚才说过，`s1` 和 `sl` 是暂时性的共享存储空间，那什么时候 `s1` 单独分开存储空间呢？**只有当`s1` 现有的存储空间满了之后，自己需要扩容的时候 `s1` 便会开辟一个新的存储空间和 `sl` 分家。** 我们也可以利用这个特性，让 `sl` 和 `s1` 里面分家，注意下面的代码：

```go
sl := []int{1, 8, 7, 4, 4, 5, 2, 4, 10, 0}

// 切割时使用第三个参数，定义切割后的容量大小，cap = 5 - 1
s1 := sl[1:5:5]
// 再存入一个新的元素
s1 = append(s1, 6)

s1[0] = 100
fmt.Printf("sl: %v \n", sl)
fmt.Printf("s1: %v \n", s1)

```

在切割 `sl` 时我们使用了第三个值：`sl[1:5:5]` 这个 最后这个 `5` 代表的是新的 `s1` 容量 `cap` 大小，这里指定为 `5` 表示 `s1` 现在有 len: `5-1 = 4` 个元素，且 cap: `5 - 1 = 4`，即新子切片已经满了，要是再存一个就装不下了，就要扩容。因此，接下来当我们再往里存一个 `6` 这个新元素时，就会触发扩容机制。然后存储空间就会彻底分开！然后再对 `s1` 元素进程任何操作都没任何副作用啦！

```
sl: [1 8 7 4 4 5 2 4 10 0]
s1: [100 7 4 4 6]
```

不过上面的两个步骤是缺一不可的，如果仅仅切割不扩容，那么不管是对 `s1` 还是对 `sl` 操作，还是会相互影响！！




